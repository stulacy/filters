# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Simple Moving Average
#' 
#' Smoothes a series by means of a windowed mean.
#' If x is an input series and y is the output filtered series,
#' then:
#' \deqn{y[i] = \frac{\sigma_{j=i - \text{window_size} + 1}^{i} x[i]}{\text{window_size}}}{y[i] = mean(x[(i-window_size+1) : i])}
#' 
#' @param x Input time-series as a vector.
#' @param window_size Window size as an integer
#' @param recentre Whether to recentre the window around the middle point in the window so as to avoid
#'   adding lag. I.e. for an odd window_length y[i] = mean(x[(i - floor(window_length/2)) : (i + floor(window_length/2))])
#'   For an even window length the output is located more closely to earlier points, i.e.
#'   y[i] = mean(x[(i - window_length/2 + 1) : (i + window_length/2)])
#' @param miss How to handle missing values. 'single' only returns NA for y[i] if x[i] = NA.
#'   'all' returns NA for y[i] if any value in the window is missing, and 'none' omits NAs from the window,
#'   so will only return NA for y[i] if all windowed values are also NA.
#' @return A filtered time-series the same length as x.
sma <- function(x, window_size, recentre = TRUE, miss = "single") {
    .Call(`_filters_sma`, x, window_size, recentre, miss)
}

#' Exponential Moving Average
#' 
#' Smoothes a series by means of an exponential moving average.
#' If x is an input series and y is the output filtered series,
#' then:
#' \deqn{y[i] = \alpha x[i] + (1-\alpha)y[i-1]}{y[i] = alpha * x[i] + (1-alpha) * y[i-1]}
#' 
#' @param x Input time-series as a vector.
#' @param alpha Smoothing parameter, lower values have a greater smoothing effect.
#' @param miss How to handle missing data. 
#' When 'reset' is used and x[i] is NA then y[i] is also NA.
#' On the next non-NA value, j, then the rolling average is reset 
#' by using the current input, i.e.
#' x[j] = alpha * x[j] + (1-alpha) * x[j]
#' With 'carry' then the last non-NA value is carried over and used instead, i.e.
#' if x = [1, NA, 3] then y[3] = alpha * 3 + (1-alpha) * y[1]
#' 'carry_interpolate' is the same as 'carry' except that the previous non-NA 
#' value is also output from the filter.
#' I.e. with x = [1, NA, 3], then under 'carry' y[2] = NA but under 'carry_interpolate'
#' y[2] = 1
#' @return A filtered time-series the same length as x.
ema <- function(x, alpha, miss = "reset") {
    .Call(`_filters_ema`, x, alpha, miss)
}

#' Hampel Filter for outlier removal
#' 
#' Smoothes a series by removing outliers.
#' Outliers are detected by being more than a standard deviations from the
#' median absolute deviation.
#' Non-outliers aren't affected.
#' The a parameter scales the standard deviations to have the CDF of a normal
#' distribution.
#' 
#' @param x Input time-series as a vector.
#' @param window_size Window size as an integer
#' @param recentre Whether to recentre the window around the middle point in the window so as to avoid
#'   adding lag. I.e. for an odd window_length y[i] = mean(x[(i - floor(window_length/2)) : (i + floor(window_length/2))])
#'   For an even window length the output is located more closely to earlier points, i.e.
#'   y[i] = mean(x[(i - window_length/2 + 1) : (i + window_length/2)])
#' @param a Threshold number of standard deviations from the median absolute deviation to 
#' classify outliers as.
#' @param k Tuning parameter to convert standard deviations to a normal CDF.
#' @param miss How to handle missing values. 'single' only returns NA for y[i] if x[i] = NA.
#'   'all' returns NA for y[i] if any value in the window is missing, and 'none' omits NAs from the window,
#'   so will only return NA for y[i] if all windowed values are also NA.
#' @return A filtered time-series the same length as x.
hampel <- function(x, window_size, a = 3.0, k = 1.4826, recentre = TRUE, miss = "single") {
    .Call(`_filters_hampel`, x, window_size, a, k, recentre, miss)
}

